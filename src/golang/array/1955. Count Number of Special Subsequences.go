package array

//输入：nums = [0,1,2,0,1,2]
//输出：7
//解释：特殊子序列包括：
//- [0,1,2,0,1,2]
//- [0,1,2,0,1,2]
//- [0,1,2,0,1,2]
//- [0,1,2,0,1,2]
//- [0,1,2,0,1,2]
//- [0,1,2,0,1,2]
//- [0,1,2,0,1,2]

func CountSpecialSubsequences(nums []int) int {
	var l int = len(nums)
	//dp[i][0]: 以0结尾的子序列总数
	var dp [][3]int = make([][3]int,l + 1)
	for i := 0;i < l;i++{
		if nums[i] == 0{
			dp[i + 1][0] = dp[i][0] * 2 + 1 //1、添加当前的0到之前的0序列，2、不添加当前0，使用之前的0序列，3、使用一个0
			dp[i + 1][0] %= 1e9 + 7
			dp[i + 1][1] = dp[i][1]
			dp[i + 1][2] = dp[i][2]
		}else if nums[i] == 1{
			if dp[i][0] > 0{
				dp[i + 1][1] = dp[i][1] * 2 + dp[i][0]//1、不添加当前1，使用之前的1序列，2、添加当前1到之前的1序列，，3、添加当前1到之前的0序列
				dp[i + 1][1] %= 1e9 + 7
			}else{
				dp[i + 1][1] = dp[i][1]
			}
			dp[i + 1][0] = dp[i][0]
			dp[i + 1][2] = dp[i][2]
		}else if nums[i] == 2{
			if dp[i][1] > 0{
				dp[i + 1][2] = dp[i][2] * 2 + dp[i][1] //1、使用之前的2序列，2、添加当前2到之前2序列，2、添加当前2到之前1序列
				dp[i + 1][2] %= 1e9 + 7
			}else{
				dp[i + 1][2] = dp[i][2]
			}
			dp[i + 1][0] = dp[i][0]
			dp[i + 1][1] = dp[i][1]
		}
	}
	return dp[l][2]
}