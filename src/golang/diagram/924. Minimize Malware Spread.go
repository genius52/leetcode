package diagram

import "sort"

//当 graph[i][j] = 1 时，每个节点 i 能够直接连接到另一个节点 j

//输入：graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
//输出：0

//找出只有一个感染点的组

//func find_group(groups []int,i int)int {
//	if groups[i] == i{
//		return i
//	}
//	parent := find_group(groups,groups[i])
//	//groups[i] = parent
//	return parent
//}

func dfs_minMalwareSpread(graph [][]int,cur int,group_num int,groups []int,visited []bool){
	if visited[cur]{
		return
	}
	groups[cur] = group_num
	visited[cur] = true
	var l int = len(graph[cur])
	for i := 0;i < l;i++{
		if i == cur || graph[cur][i] == 0{
			continue
		}
		dfs_minMalwareSpread(graph,i,group_num,groups,visited)
	}
}

func MinMalwareSpread(graph [][]int, initial []int) int {
	sort.Ints(initial)
	var l int = len(graph)
	var groups []int = make([]int,l)
	for i := 0;i < l;i++{
		groups[i] = i//自己单独一组
	}
	for _,n := range initial{
		if groups[n] != n{//已经有组了
			continue
		}
		var visited []bool = make([]bool,l)
		dfs_minMalwareSpread(graph,n,n,groups,visited)
	}
	//寻找只有一个污染点的组
	var keys [301]bool
	for _,n := range initial{
		keys[n] = true
	}
	var groupnum_cnt map[int]int = make(map[int]int)
	for _,n := range groups{
		if !keys[n]{//没有污染的组
			continue
		}
		if _,ok := groupnum_cnt[n];ok{
			groupnum_cnt[n]++
		}else{
			groupnum_cnt[n] = 1
		}
	}
	var nums []int
	for n,_ := range groupnum_cnt{ //找出只有一个污染点的组
		var total int = 0
		for _,num := range initial{
			if groups[num] == n{
				total++
			}
		}
		if total == 1{
			nums = append(nums,n)
		}
	}
	if len(nums) == 0{
		return initial[0]
	}
	sort.Ints(nums)
	var res int = 0
	var max_members int = 0
	//计算最大成员数的组号
	for _,num := range nums{
		if groupnum_cnt[num] > max_members{
			res = num
			max_members = groupnum_cnt[num]
		}
	}
	return res
}